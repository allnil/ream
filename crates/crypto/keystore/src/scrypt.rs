use std::thread;

use anyhow::{anyhow, ensure};

use crate::{pbkdf2::pbkdf2, salsa::salsa20_8_core};

fn scrypt_block_mix(block_size: usize, input_output: &mut [u8]) {
    let mut block_x = [0u8; 64];
    block_x.copy_from_slice(&input_output[(2 * block_size - 1) * 64..2 * block_size * 64]);

    for block_index in 0..2 * block_size {
        let block_offset = block_index * 64;
        for byte_index in 0..64 {
            block_x[byte_index] ^= input_output[block_offset + byte_index];
        }
        salsa20_8_core(&mut block_x);
        input_output[block_offset..block_offset + 64].copy_from_slice(&block_x);
    }

    let mut rearranged_blocks = vec![0u8; input_output.len()];
    for block_index in 0..block_size {
        rearranged_blocks[block_index * 64..(block_index + 1) * 64]
            .copy_from_slice(&input_output[block_index * 128..block_index * 128 + 64]);
        rearranged_blocks[(block_size + block_index) * 64..(block_size + block_index + 1) * 64]
            .copy_from_slice(&input_output[block_index * 128 + 64..(block_index + 1) * 128]);
    }

    input_output.copy_from_slice(&rearranged_blocks);
}

fn scrypt_romix(block_size: usize, input_output: &mut [u8], cost_parameter: usize) {
    let block_size_in_bytes = 128 * block_size;
    let mut memory_space = vec![0u8; cost_parameter * block_size_in_bytes];

    for iteration in 0..cost_parameter {
        let memory_offset = iteration * block_size_in_bytes;
        memory_space[memory_offset..memory_offset + block_size_in_bytes]
            .copy_from_slice(input_output);
        scrypt_block_mix(block_size, input_output);
    }

    let mut temp_block = vec![0u8; block_size_in_bytes];
    for _ in 0..cost_parameter {
        let memory_index = {
            let mut last_eight_bytes_array = [0u8; 8];
            last_eight_bytes_array
                .copy_from_slice(&input_output[block_size_in_bytes - 64..block_size_in_bytes - 56]);
            (u64::from_le_bytes(last_eight_bytes_array) & (cost_parameter as u64 - 1)) as usize
        };

        let memory_block = &memory_space
            [memory_index * block_size_in_bytes..(memory_index + 1) * block_size_in_bytes];
        for byte_index in 0..block_size_in_bytes {
            temp_block[byte_index] = input_output[byte_index] ^ memory_block[byte_index];
        }

        input_output.copy_from_slice(&temp_block);
        scrypt_block_mix(block_size, input_output);
    }
}

pub fn scrypt(
    password: &[u8],
    salt: &[u8],
    cost_parameter: u64,
    parallelization_parameter: u64,
    block_size: u64,
    derived_key_length: u64,
) -> anyhow::Result<Vec<u8>> {
    // The reason we don't need to do any result wraps for the helper functions is beause these
    // ensure statements make it impossible for it to error
    ensure!(
        cost_parameter > 1 && cost_parameter.is_power_of_two(),
        "cost_parameter must be larger than 1 and a power of 2."
    );
    ensure!(
        parallelization_parameter > 0
            && parallelization_parameter <= (u32::MAX as u64) / (4 * block_size),
        "parallelization_parameter must be a positive integer less than or equal to (2^32-1) / (4 * block_size)."
    );
    ensure!(
        derived_key_length > 0 && derived_key_length <= (u32::MAX as u64) * 32,
        "dkLen must be a positive integer less than or equal to (2^32 - 1) * 32."
    );

    let block_size_in_bytes = 128 * block_size as usize;
    let total_memory_size = block_size_in_bytes * parallelization_parameter as usize;

    let mut initial_key = pbkdf2(password, salt, 1, total_memory_size as u64)?;
    let mut thread_handles = Vec::with_capacity(parallelization_parameter as usize);

    // If this parameter is big, it can take a while, multithreaded as a result
    for thread_index in 0..parallelization_parameter as usize {
        let mut thread_chunk = initial_key
            [thread_index * block_size_in_bytes..(thread_index + 1) * block_size_in_bytes]
            .to_vec();

        thread_handles.push(thread::spawn(move || {
            scrypt_romix(
                block_size as usize,
                &mut thread_chunk,
                cost_parameter as usize,
            );
            (thread_index, thread_chunk)
        }));
    }
    for thread_handle in thread_handles {
        let (thread_index, thread_result) = thread_handle
            .join()
            .map_err(|err| anyhow!("Failed to join thread while doin scrypt_romix: {err:?}"))?;
        initial_key[thread_index * block_size_in_bytes..(thread_index + 1) * block_size_in_bytes]
            .copy_from_slice(&thread_result);
    }
    pbkdf2(password, &initial_key, 1, derived_key_length)
}

#[cfg(test)]
mod tests {
    use crate::scrypt::{scrypt, scrypt_block_mix, scrypt_romix};

    #[test]
    fn test_scrypt_block_mix() {
        let block_size = 1;
        let mut input_output = [
            0xf7, 0xce, 0x0b, 0x65, 0x3d, 0x2d, 0x72, 0xa4, 0x10, 0x8c, 0xf5, 0xab, 0xe9, 0x12,
            0xff, 0xdd, 0x77, 0x76, 0x16, 0xdb, 0xbb, 0x27, 0xa7, 0x0e, 0x82, 0x04, 0xf3, 0xae,
            0x2d, 0x0f, 0x6f, 0xad, 0x89, 0xf6, 0x8f, 0x48, 0x11, 0xd1, 0xe8, 0x7b, 0xcc, 0x3b,
            0xd7, 0x40, 0x0a, 0x9f, 0xfd, 0x29, 0x09, 0x4f, 0x01, 0x84, 0x63, 0x95, 0x74, 0xf3,
            0x9a, 0xe5, 0xa1, 0x31, 0x52, 0x17, 0xbc, 0xd7, 0x89, 0x49, 0x91, 0x44, 0x72, 0x13,
            0xbb, 0x22, 0x6c, 0x25, 0xb5, 0x4d, 0xa8, 0x63, 0x70, 0xfb, 0xcd, 0x98, 0x43, 0x80,
            0x37, 0x46, 0x66, 0xbb, 0x8f, 0xfc, 0xb5, 0xbf, 0x40, 0xc2, 0x54, 0xb0, 0x67, 0xd2,
            0x7c, 0x51, 0xce, 0x4a, 0xd5, 0xfe, 0xd8, 0x29, 0xc9, 0x0b, 0x50, 0x5a, 0x57, 0x1b,
            0x7f, 0x4d, 0x1c, 0xad, 0x6a, 0x52, 0x3c, 0xda, 0x77, 0x0e, 0x67, 0xbc, 0xea, 0xaf,
            0x7e, 0x89,
        ];

        let expected_output = [
            0xa4, 0x1f, 0x85, 0x9c, 0x66, 0x08, 0xcc, 0x99, 0x3b, 0x81, 0xca, 0xcb, 0x02, 0x0c,
            0xef, 0x05, 0x04, 0x4b, 0x21, 0x81, 0xa2, 0xfd, 0x33, 0x7d, 0xfd, 0x7b, 0x1c, 0x63,
            0x96, 0x68, 0x2f, 0x29, 0xb4, 0x39, 0x31, 0x68, 0xe3, 0xc9, 0xe6, 0xbc, 0xfe, 0x6b,
            0xc5, 0xb7, 0xa0, 0x6d, 0x96, 0xba, 0xe4, 0x24, 0xcc, 0x10, 0x2c, 0x91, 0x74, 0x5c,
            0x24, 0xad, 0x67, 0x3d, 0xc7, 0x61, 0x8f, 0x81, 0x20, 0xed, 0xc9, 0x75, 0x32, 0x38,
            0x81, 0xa8, 0x05, 0x40, 0xf6, 0x4c, 0x16, 0x2d, 0xcd, 0x3c, 0x21, 0x07, 0x7c, 0xfe,
            0x5f, 0x8d, 0x5f, 0xe2, 0xb1, 0xa4, 0x16, 0x8f, 0x95, 0x36, 0x78, 0xb7, 0x7d, 0x3b,
            0x3d, 0x80, 0x3b, 0x60, 0xe4, 0xab, 0x92, 0x09, 0x96, 0xe5, 0x9b, 0x4d, 0x53, 0xb6,
            0x5d, 0x2a, 0x22, 0x58, 0x77, 0xd5, 0xed, 0xf5, 0x84, 0x2c, 0xb9, 0xf1, 0x4e, 0xef,
            0xe4, 0x25,
        ];

        scrypt_block_mix(block_size, &mut input_output);
        assert_eq!(input_output, expected_output);
    }

    #[test]
    fn test_scrypt_romix() {
        let block_size = 1;
        let cost_parameter = 16;
        let mut input_output = [
            0xf7, 0xce, 0x0b, 0x65, 0x3d, 0x2d, 0x72, 0xa4, 0x10, 0x8c, 0xf5, 0xab, 0xe9, 0x12,
            0xff, 0xdd, 0x77, 0x76, 0x16, 0xdb, 0xbb, 0x27, 0xa7, 0x0e, 0x82, 0x04, 0xf3, 0xae,
            0x2d, 0x0f, 0x6f, 0xad, 0x89, 0xf6, 0x8f, 0x48, 0x11, 0xd1, 0xe8, 0x7b, 0xcc, 0x3b,
            0xd7, 0x40, 0x0a, 0x9f, 0xfd, 0x29, 0x09, 0x4f, 0x01, 0x84, 0x63, 0x95, 0x74, 0xf3,
            0x9a, 0xe5, 0xa1, 0x31, 0x52, 0x17, 0xbc, 0xd7, 0x89, 0x49, 0x91, 0x44, 0x72, 0x13,
            0xbb, 0x22, 0x6c, 0x25, 0xb5, 0x4d, 0xa8, 0x63, 0x70, 0xfb, 0xcd, 0x98, 0x43, 0x80,
            0x37, 0x46, 0x66, 0xbb, 0x8f, 0xfc, 0xb5, 0xbf, 0x40, 0xc2, 0x54, 0xb0, 0x67, 0xd2,
            0x7c, 0x51, 0xce, 0x4a, 0xd5, 0xfe, 0xd8, 0x29, 0xc9, 0x0b, 0x50, 0x5a, 0x57, 0x1b,
            0x7f, 0x4d, 0x1c, 0xad, 0x6a, 0x52, 0x3c, 0xda, 0x77, 0x0e, 0x67, 0xbc, 0xea, 0xaf,
            0x7e, 0x89,
        ];

        let expected_output = [
            0x79, 0xcc, 0xc1, 0x93, 0x62, 0x9d, 0xeb, 0xca, 0x04, 0x7f, 0x0b, 0x70, 0x60, 0x4b,
            0xf6, 0xb6, 0x2c, 0xe3, 0xdd, 0x4a, 0x96, 0x26, 0xe3, 0x55, 0xfa, 0xfc, 0x61, 0x98,
            0xe6, 0xea, 0x2b, 0x46, 0xd5, 0x84, 0x13, 0x67, 0x3b, 0x99, 0xb0, 0x29, 0xd6, 0x65,
            0xc3, 0x57, 0x60, 0x1f, 0xb4, 0x26, 0xa0, 0xb2, 0xf4, 0xbb, 0xa2, 0x00, 0xee, 0x9f,
            0x0a, 0x43, 0xd1, 0x9b, 0x57, 0x1a, 0x9c, 0x71, 0xef, 0x11, 0x42, 0xe6, 0x5d, 0x5a,
            0x26, 0x6f, 0xdd, 0xca, 0x83, 0x2c, 0xe5, 0x9f, 0xaa, 0x7c, 0xac, 0x0b, 0x9c, 0xf1,
            0xbe, 0x2b, 0xff, 0xca, 0x30, 0x0d, 0x01, 0xee, 0x38, 0x76, 0x19, 0xc4, 0xae, 0x12,
            0xfd, 0x44, 0x38, 0xf2, 0x03, 0xa0, 0xe4, 0xe1, 0xc4, 0x7e, 0xc3, 0x14, 0x86, 0x1f,
            0x4e, 0x90, 0x87, 0xcb, 0x33, 0x39, 0x6a, 0x68, 0x73, 0xe8, 0xf9, 0xd2, 0x53, 0x9a,
            0x4b, 0x8e,
        ];

        scrypt_romix(block_size, &mut input_output, cost_parameter);
        assert_eq!(input_output, expected_output);
    }

    #[test]
    fn test_scrypt_empty_password_and_salt() {
        let password = b"";
        let salt = b"";
        let cost_parameter = 16;
        let block_size = 1;
        let parallelization_parameter = 1;
        let derived_key_length = 64;

        let expected_output: Vec<u8> = vec![
            0x77, 0xd6, 0x57, 0x62, 0x38, 0x65, 0x7b, 0x20, 0x3b, 0x19, 0xca, 0x42, 0xc1, 0x8a,
            0x04, 0x97, 0xf1, 0x6b, 0x48, 0x44, 0xe3, 0x07, 0x4a, 0xe8, 0xdf, 0xdf, 0xfa, 0x3f,
            0xed, 0xe2, 0x14, 0x42, 0xfc, 0xd0, 0x06, 0x9d, 0xed, 0x09, 0x48, 0xf8, 0x32, 0x6a,
            0x75, 0x3a, 0x0f, 0xc8, 0x1f, 0x17, 0xe8, 0xd3, 0xe0, 0xfb, 0x2e, 0x0d, 0x36, 0x28,
            0xcf, 0x35, 0xe2, 0x0c, 0x38, 0xd1, 0x89, 0x06,
        ];

        let output = scrypt(
            password,
            salt,
            cost_parameter,
            parallelization_parameter,
            block_size,
            derived_key_length,
        )
        .unwrap();
        assert_eq!(output, expected_output);
    }

    #[test]
    fn test_scrypt_password_and_salt_nacl() {
        let password = b"password";
        let salt = b"NaCl";
        let cost_parameter = 1024;
        let block_size = 8;
        let parallelization_parameter = 16;
        let derived_key_length = 64;

        let expected_output: Vec<u8> = vec![
            0xfd, 0xba, 0xbe, 0x1c, 0x9d, 0x34, 0x72, 0x00, 0x78, 0x56, 0xe7, 0x19, 0x0d, 0x01,
            0xe9, 0xfe, 0x7c, 0x6a, 0xd7, 0xcb, 0xc8, 0x23, 0x78, 0x30, 0xe7, 0x73, 0x76, 0x63,
            0x4b, 0x37, 0x31, 0x62, 0x2e, 0xaf, 0x30, 0xd9, 0x2e, 0x22, 0xa3, 0x88, 0x6f, 0xf1,
            0x09, 0x27, 0x9d, 0x98, 0x30, 0xda, 0xc7, 0x27, 0xaf, 0xb9, 0x4a, 0x83, 0xee, 0x6d,
            0x83, 0x60, 0xcb, 0xdf, 0xa2, 0xcc, 0x06, 0x40,
        ];

        let output = scrypt(
            password,
            salt,
            cost_parameter,
            parallelization_parameter,
            block_size,
            derived_key_length,
        )
        .unwrap();
        assert_eq!(output, expected_output);
    }

    #[test]
    fn test_scrypt_pleaseletmein_sodiumchloride() {
        let password = b"pleaseletmein";
        let salt = b"SodiumChloride";
        let cost_parameter = 16384;
        let block_size = 8;
        let parallelization_parameter = 1;
        let derived_key_length = 64;

        let expected_output: Vec<u8> = vec![
            0x70, 0x23, 0xbd, 0xcb, 0x3a, 0xfd, 0x73, 0x48, 0x46, 0x1c, 0x06, 0xcd, 0x81, 0xfd,
            0x38, 0xeb, 0xfd, 0xa8, 0xfb, 0xba, 0x90, 0x4f, 0x8e, 0x3e, 0xa9, 0xb5, 0x43, 0xf6,
            0x54, 0x5d, 0xa1, 0xf2, 0xd5, 0x43, 0x29, 0x55, 0x61, 0x3f, 0x0f, 0xcf, 0x62, 0xd4,
            0x97, 0x05, 0x24, 0x2a, 0x9a, 0xf9, 0xe6, 0x1e, 0x85, 0xdc, 0x0d, 0x65, 0x1e, 0x40,
            0xdf, 0xcf, 0x01, 0x7b, 0x45, 0x57, 0x58, 0x87,
        ];

        let output = scrypt(
            password,
            salt,
            cost_parameter,
            parallelization_parameter,
            block_size,
            derived_key_length,
        )
        .unwrap();
        assert_eq!(output, expected_output);
    }
}
